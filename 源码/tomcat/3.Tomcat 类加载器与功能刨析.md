# ***Tomcat 功能刨析***

- [***Tomcat 功能刨析***](#tomcat-功能刨析)
  - [一、Tomcat 热加载与热部署](#一tomcat-热加载与热部署)
      - [Tomcat 热加载](#tomcat-热加载)
      - [Tomcat 热部署](#tomcat-热部署)
  - [二、Tomcat 类加载器](#二tomcat-类加载器)
      - [Java 类加载器](#java-类加载器)

----

## 一、Tomcat 热加载与热部署

要在运行的过程中升级 Web 应用，如果你不想重启系统，实现的方式有两种：热加载和热部署。

>- 热加载的实现方式是 Web 容器启动一个后台线程，定期检测类文件的变化，如果有变化，就重新加载类，在这个过程中不会清空 Session ，一般用在开发环境。
>
>- 热部署原理类似，也是由后台线程定时检测 Web 应用的变化，但它会重新加载整个 Web 应用。这种方式会清空 Session，比热加载更加干净、彻底，一般用在生产环境。

Tomcat 就是通过开启后台线程实现：

```java
/**
* ContainerBase.java
* Start the background thread that will periodically check for
* session timeouts.
*/
protected void threadStart() {
    if (thread != null) return;
    if (backgroundProcessorDelay <= 0) return;
    threadDone = false;
    String threadName = "ContainerBackgroundProcessor[" + toString() + "]";
    thread = new Thread(new ContainerBackgroundProcessor(), threadName);
    thread.setDaemon(true);
    thread.start();
}
```

任务类 ContainerBackgroundProcessor，它是一个 Runnable，同时也是 ContainerBase 的内部类，ContainerBase 是所有容器组件的基类。

```java
/**
* ContainerBackgroundProcessor.java
* Private runnable class to invoke the backgroundProcess method
* of this container and its children after a fixed delay.
*/
protected class ContainerBackgroundProcessor implements Runnable {

    @Override
    public void run() {
        Throwable t = null;
        String unexpectedDeathMessage = sm.getString( "containerBase.backgroundProcess.unexpectedThreadDeath", Thread.currentThread().getName());
        try {
            while (!threadDone) {
                try {
                    Thread.sleep(backgroundProcessorDelay * 1000L);
                } catch (InterruptedException e) {
                    // Ignore
                }
                if (!threadDone) {
                    processChildren(ContainerBase.this);
                }
            }
        } catch (RuntimeException|Error e) {
            ···
        } finally {
            ···
        }
    }

    protected void processChildren(Container container) {
        ClassLoader originalClassLoader = null;

        try {
            if (container instanceof Context) {
                Loader loader = ((Context) container).getLoader();
                // Loader will be null for FailedContext instances
                if (loader == null) {
                    return;
                }

                // Ensure background processing for Contexts and Wrappers
                // is performed under the web app's class loader
                originalClassLoader = ((Context) container).bind(false, null);
            }
            //1. 调用当前容器的 backgroundProcess 方法。
            container.backgroundProcess();
            //2. 遍历所有的子容器，递归调用 processChildren， 
            Container[] children = container.findChildren();
            for (Container child : children) {
                // 这里请你注意，容器基类有个变量叫做 backgroundProcessorDelay
                // 如果大于0，表明子容器有自己的后台线程，无需父容器来调用它的 processChildren 方法。
                if (child.getBackgroundProcessorDelay() <= 0) {
                    processChildren(child);
                }
            }
        } catch (Throwable t) { ··· } finally {
            if (container instanceof Context) {
                ((Context) container).unbind(false, originalClassLoader);
            }
        }
    }
}
```

```java
/**
* Execute a periodic task, such as reloading, etc. This method will be
* invoked inside the classloading context of this container. Unexpected
* throwables will be caught and logged.
*/
@Override
public void backgroundProcess() {

    if (!getState().isAvailable())
        return;
    
    //1.执行容器中 Cluster 组件的周期性任务
    Cluster cluster = getClusterInternal();
    if (cluster != null) {
        try {
            cluster.backgroundProcess();
        } catch (Exception e) {
            ···
        }
    }
    //2.执行容器中 Realm 组件的周期性任务
    Realm realm = getRealmInternal();
    if (realm != null) {
        try {
            realm.backgroundProcess();
        } catch (Exception e) {
            ···
        }
    }

    //3.执行容器中 Valve 组件的周期性任务
    Valve current = pipeline.getFirst();
    while (current != null) {
        try {
            current.backgroundProcess();
        } catch (Exception e) {
            ···
        }
        current = current.getNext();
    }
    //4. 触发容器的"周期事件"，Host 容器的监听器 HostConfig 就靠它来调用
    fireLifecycleEvent(Lifecycle.PERIODIC_EVENT, null);
}
```

从上面的代码可以看到，不仅每个容器可以有周期性任务，每个容器中的其他通用组件，比如跟集群管理有关的 Cluster 组件、跟安全管理有关的 Realm 组件都可以有自己的周期性任务。

#### Tomcat 热加载

有了 ContainerBase 的周期性任务处理“框架”，作为具体容器子类，只需要实现自己的周期性任务就行。而 Tomcat 的热加载，就是在 Context 容器中实现的。Context 容器的 backgroundProcess 方法是这样实现的：

```java
@Override
public void backgroundProcess() {

    if (!getState().isAvailable()) return;
    
    //WebappLoader 周期性的检查 WEB-INF/classes 和 WEB-INF/lib 目录下的类文件
    Loader loader = getLoader();
    if (loader != null) {
        try {
            loader.backgroundProcess();
        } catch (Exception e) {···}
    }

    //Session 管理器周期性的检查是否有过期的 Session
    Manager manager = getManager();
    if (manager != null) {
        try {
            manager.backgroundProcess();
        } catch (Exception e) {···}
    }

    //周期性的检查静态资源是否有变化
    WebResourceRoot resources = getResources();
    if (resources != null) {
        try {
            resources.backgroundProcess();
        } catch (Exception e) {···}
    }

    //实例管理器，定期清理过期引用
    InstanceManager instanceManager = getInstanceManager();
    if (instanceManager instanceof DefaultInstanceManager) {
        try {
            ((DefaultInstanceManager)instanceManager).backgroundProcess();
        } catch (Exception e) {···}
    }

    //调用父类ContainerBase的backgroundProcess方法
    super.backgroundProcess();
}
```

从上面的代码我们看到 Context 容器通过 WebappLoader 来检查类文件是否有更新，通过 Session 管理器来检查是否有 Session 过期，并且通过资源管理器来检查静态资源是否有更新，最后还调用了父类 ContainerBase 的 backgroundProcess 方法。

WebappLoader 是如何实现热加载的，它主要是调用了 Context 容器的 reload 方法，而 Context 的 reload 方法比较复杂，总结起来，主要完成了下面这些任务：

>- 停止和销毁 Context 容器及其所有子容器，子容器其实就是 Wrapper，也就是说 Wrapper 里面 Servlet 实例也被销毁了（在这里 Context 实例并没有销毁）。
>- 停止和销毁 Context 容器关联的 Listener 和 Filter。
>- 停止和销毁 Context 下的 Pipeline 和各种 Valve。
>- 停止和销毁 Context 的类加载器，以及类加载器加载的类文件资源。
>- 启动 Context 容器，在这个过程中会重新创建前面四步被销毁的资源。
>- 在这个过程中，类加载器发挥着关键作用。一个 Context 容器对应一个类加载器，类加载器在销毁的过程中会把它加载的所有类也全部销毁。Context 容器在启动过程中，会创建一个新的类加载器来加载新的类文件。

在 Context 的 reload 方法里，并没有调用 Session 管理器的 destroy 方法，也就是说这个 Context 关联的 Session 是没有销毁的。你还需要注意的是，Tomcat 的热加载默认是关闭的，你需要在 conf 目录下的 server.xml 文件中设置 reloadable 参数来开启这个功能，像下面这样：
```xml
<Context path="/testweb1" docBase="testweb.war"  reloadbale="true"/>
```

#### Tomcat 热部署

热部署跟热加载的本质区别是，热部署会重新部署 Web 应用，原来的 Context 对象会整个被销毁掉，因此这个 Context 所关联的一切资源都会被销毁，包括 Session。

那么 Tomcat 热部署又是由哪个容器来实现的呢？ 因为热部署过程中 Context 容器被销毁了，那么这个重担就落在 Host 身上了，因为它是 Context 的父容器。

跟 Context 不一样，Host 容器并没有在 backgroundProcess 方法中实现周期性检测的任务，而是通过监听器 HostConfig 来实现的，HostConfig 就是前面提到的“周期事件”的监听器，那“周期事件”达到时，HostConfig 会做什么事呢？

```java
/**
* LifecycleBase.java
* Allow sub classes to fire {@link Lifecycle} events.
*
* @param type  Event type
* @param data  Data associated with event.
*/
protected void fireLifecycleEvent(String type, Object data) {
    LifecycleEvent event = new LifecycleEvent(this, type, data);
    for (LifecycleListener listener : lifecycleListeners) {
        listener.lifecycleEvent(event);
    }
}
```

它执行了 check 方法，我们接着来看 check 方法里做了什么

```java
/**
* HostConfig.java
* Check status of all webapps.
*/
protected void check() {
    if (host.getAutoDeploy()) {
        // Check for resources modification to trigger redeployment
        // 检查这个 Host 下所有已经部署的 Web 应用
        DeployedApplication[] apps = deployed.values().toArray(new DeployedApplication[0]);
        for (DeployedApplication app : apps) {
            if (tryAddServiced(app.name)) {
                //检查Web应用目录是否有变化
                try { checkResources(app, false); } 
                finally { removeServiced(app.name); }
            }
        }
        // Check for old versions of applications that can now be undeployed
        if (host.getUndeployOldVersions()) {
            checkUndeploy();
        }
        // Hot deploy applications
        deployApps();
    }
}
```

其实 HostConfig 会检查 webapps 目录下的所有 Web 应用：

>- 如果原来 Web 应用目录被删掉了，就把相应 Context 容器整个销毁掉。
>- 是否有新的 Web 应用目录放进来了，或者有新的 WAR 包放进来了，就部署相应的 Web 应用。

## 二、Tomcat 类加载器

#### Java 类加载器 

Java 的类加载，就是把字节码格式`.class`文件加载到 JVM 的方法区，并在 JVM 的堆区建立一个 `java.lang.Class` 对象的实例，用来封装 Java 类相关的数据和方法。那 Class 对象又是什么呢？你可以把它理解成业务类的模板，JVM 根据这个模板来创建具体业务类对象实例。

JVM 并不是在启动时就把所有的`.class`文件都加载一遍，而是程序在运行过程中用到了这个类才去加载。JVM 类加载是由类加载器来完成的，JDK 提供一个抽象类 ClassLoader，这个抽象类中定义了三个关键方法，理解清楚它们的作用和关系非常重要(详见 <a href="../jvm/2.2 虚拟机加载机制.md/#类加载器">虚拟机加载机制</a> 章节介绍)。




