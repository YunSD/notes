# ***对于所有对象都通用的方法***

- [***对于所有对象都通用的方法***](#对于所有对象都通用的方法)
  - [10.覆盖 equals 时请遵守通用约定](#10覆盖-equals-时请遵守通用约定)
  - [11.重写 equals 方法时同时也要重写 hashcode 方法](#11重写-equals-方法时同时也要重写-hashcode-方法)

&ensp;&ensp;&ensp;&ensp;虽然 Object 是一个具体的类，但它主要是为继承而设计的。它的所有非 final 方法（equals、hashCode、toString、clone 和 finalize）都有清晰的通用约定（ general contracts），因为它们被设计为被子类重写。任何类要重写这些方法时，都有义务去遵从它们的通用约定；如果不这样做，将会阻止其他依赖于约定的类 (例如 HashMap 和 HashSet) 与此类一起正常工作。

## 10.覆盖 equals 时请遵守通用约定

&ensp;&ensp;&ensp;&ensp;重写 equals 方法看起来很简单，但是有很多方式会导致重写出错，其结果可能是可怕的。避免此问题的最简单方法是不覆盖 equals 方法，在这种情况下，类的每个实例只与自身相等。如果满足以下任一下条件，则说明是所期望的结果：

- **每个类的实例都是固有唯一的。**  对于像 Thread 这样代表活动实体而不是值的类来说，这是正确的。Object 提供的 equals 实现对这些类完全是正确的行为。
- **类没有必要提供“逻辑相等（logical equality）”的测试功能。** 例如，`java.util.regex.Pattern` 可以重写 equals 方法检查两个是否代表完全相同的正则表达式 Pattern 实例，但是设计者并不认为客户需要或希望使用此功能。在这种情况下，从 Object 继承的 equals 实现是最合适的。
- **超类已经重写了 equals 方法，则父类行为完全适合于该子类。** 例如，大多数 Set 从 AbstractSet 继承了 equals 实现、List 从 AbstractList 继承了 equals 实现，Map 从 AbstractMap 的 Map 继承了 equals 实现。
- **类是私有的或包级私有的，可以确定它的 equals 方法永远不会被调用。** 如果你非常厌恶风险，可以重写 equals 方法，以确保不会被意外调用：
    ```java
    public boolean equals(Object o) { throw new AssertionError(); // Method is never called }
    ```

&ensp;&ensp;&ensp;&ensp;什么时候需要重写 equals 方法呢？如果一个类包含一个逻辑相等（logical equality）的概念，此概念有别于对象标识（object identity），而且父类还没有重写过 equals 方法。这通常用在值类（value classes）的情况。值类只是一个表示值的类，例如 Integer 或 String 类。程序员使用 equals 方法比较值对象的引用，期望发现它们在逻辑上是否相等，而不是引用相同的对象。重写 equals 方法不仅可以满
足程序员的期望，它还支持重写过 equals 的实例作为 Map 的键（key），或者 Set 里的元素，以满足预期和期望的行为。

&ensp;&ensp;&ensp;&ensp;一种不需要 equals 方法重写的值类是使用实例控制（instance control）（详见第 1 条）的类，以确保每个值至多存在一个对象。 枚举类型（详见第 34 条）属于这个类别。 对于这些类，逻辑相等与对象标识是一样的，所以 Object 的 equals 方法作用逻辑 equals 方法。

&ensp;&ensp;&ensp;&ensp;equals 方法实现了一个等价关系（equivalence relation）。它有以下这些属性:
- **自反性（Reflexivity）：** 对于任何非空引用 x， x.equals(x) 必须返回 true。
- **对称性（Symmetry）：** 对于任何非空引用 x 和 y，如果且仅当 y.equals(x) 返回 true 时 x.equals(y) 必须返回 true。
- **传递性（Transitivity）：** 对于任何非空引用 x、y、z，如果 x.equals(y) 返回 true， y.equals(z) 返回 true，则 x.equals(z) 必须返回 true。
- **一致性（Consistent）：** 对于任何非空引用 x 和 y，如果在 equals 比较中使用的信息没有修改，则x.equals(y) 的多次调用必须始终返回 true 或始终返回 false。
- **非空性（Non-nullity）：** 对于任何非空引用 x， x.equals(null) 必须返回 false。

&ensp;&ensp;&ensp;&ensp;实现高质量 equals 方法的诀窍：
1. **使用 `==` 运算符检查参数是否为该对象的引用。** 如果是，返回 true。这只是一种性能优化，但是如果这种比较可能很昂贵的话，那就值得去做。
2. **使用 instanceof 运算符来检查参数是否具有正确的类型。**  如果不是，则返回 false。 通常，正确的类型是 equals 方法所在的那个类。 有时候，改类实现了一些接口。 如果类实现了一个接口，该接口可以改进 equals 约定以允许实现接口的类进行比较，那么使用接口。 集合接口（如 Set，List，Map 和 Map.Entry）具有此特性。
3. **参数转换为正确的类型。** 因为转换操作在 instanceof 中已经处理过，所以它肯定会成功。
4. **对于类中的每个“关键(Significant)”域，请检查该参数属性是否与该对象对应的属性相匹配。**如果所有这些测试成功，返回 true，否则返回 false。如果步骤 2 中的类型是一个接口，那么必须通过接口方法访问参数的属性;如果类型是类，则可以直接访问属性，这取决于属性的访问权限。

&ensp;&ensp;&ensp;&ensp;对于类型为非 float 或 double 的基本类型，使用 `==` 运算符进行比较；对于对象引用属性，递归地调用 equals 方法；对于 float 基本类型的属性，使用静态 `Float.compare(float, float)` 方法；对于 double 基本类型的属性，使用 `Double.compare(double, double)` 方法。由于存在 `Float.NaN` ， `-0.0f` 和类似的 double 类型的值，所以需要对 float 和 double 属性进行特殊的处理；有关详细信息，请参阅 JLS 15.21.1 或 `Float.equals` 方法的详细文档。 虽然你可以使用静态方法 `Float.equals` 和 `Double.equals` 方法对 float 和 double 基本类型的属性进行比较，这会导致每次比较时发生自动装箱，引发非常差的性能。 对于数组属性，将这些准则应用于每个元素。 如果数组属性中的每个元素都很重要，请使用其中一个重载的 `Arrays.equals` 方法。

&ensp;&ensp;&ensp;&ensp;某些对象引用的属性可能合法地包含 null。 为避免出现 NullPointerException 异常，请使用静态方法 `Objects.equals(Object, Object)` 检查这些属性是否相等。

&ensp;&ensp;&ensp;&ensp;equals 方法的性能可能受到属性比较顺序的影响。 为了获得最佳性能，你应该首先比较最可能不同的属性，开销比较小的属性，或者最好是两者都满足（derived fields）。 你不要比较不属于对象逻辑状态的属性，例如用于同步操作的 lock 属性。 不需要比较可以从“重要属性”计算出来的派生属性，但是这样做可以提高 equals 方法的性能。 如果派生属性相当于对整个对象的摘要描述，比较这个属性将节省在比较失败时再去比较实际数据的开销。 例如，假设有一个 Polygon 类，并缓存该区域。 如果两个多边形的面积不相等，则不必费心比较它们的边和顶点。

&ensp;&ensp;&ensp;&ensp;下面是最后的一些告诫：
1. **当重写 equals 方法时，同时也要重写 hashCode 方法（详见第 11 条）。**
2. **不要让 equals 方法试图太聪明。** 如果只是简单地测试用于相等的属性，那么要遵守 equals 约定并不困难。如果你在寻找相等方面过于激进，那么很容易陷入麻烦。一般来说，考虑到任何形式的别名通常是一个坏主意。例如，File 类不应该试图将引用的符号链接等同于同一文件对象。幸好 File 类并没这么做。
3. **在 equal 时方法声明中，不要将参数 Object 替换成其他类型。** 对于程序员来说，编写一个如下所示的 equals 方法，然后花上几个小时苦苦思索为什么不能正常工作的情况并不少见：
    ```java
    // Still broken, but won’t compile
    @Override
    public boolean equals(MyClass o) {
        …
    }
    ```
    &ensp;&ensp;&ensp;&ensp; 问题在于这个方法并没有重写 Object.equals 方法，它的参数是 Object 类型的，这样写只是重载了equals 方法（详见第 52 条）。 即使除了正常的方法之外，提供这种“强类型”的 equals 方法也是不可接受的，因为它可能会导致子类中的 Override 注解产生误报，提供不安全的错觉。在这里，使用 Override 注解会阻止你犯这个错误 （详见第 40 条）。这个 equals 方法不会编译，错误消息会告诉你到底错在哪里。

&ensp;&ensp;&ensp;&ensp;除非必须：在很多情况下，不要重写 equals 方法，从 Object 继承的实现完全是你想要的。如果你确实重写了 equals 方法，那么一定要比较这个类的所有重要属性，并且以保护前面 equals 约定里五个规定的方式去比较。

## 11.重写 equals 方法时同时也要重写 hashcode 方法

&ensp;&ensp;&ensp;&ensp;**在每个覆盖了 equals 方法的类中，都必须覆盖 hashcode 方法。** 如果不这样做，就会违反 hashCode 的通用约定，这会阻止它在 HashMap 和 HashSet 这样的集合中正常工作。根据 Object 规范，以下是具体约定：
- 在应用程序的执行期间，只要对象的 equals 方法的比较操作所用到的信息没有被修改，那么对同一个对象的多次调用，hashCode 方法都必须始终返回同一个值。在一个应用程序与另一个程序的执行过程中，执行 hashCode 方法所返回的值可以不一致。
- 如果两个对象根据 `equals(Object)` 方法比较是相等的，那么在两个对象上调用 hashCode 就必须产生相同的整数结果。
- 如果两个对象根据 `equals(Object)` 方法比较并不相等，则不要求在每个对象上调用 hashCode 都必须产生不同的结果。 但是，程序员应该意识到，为不相等的对象生成不同的结果可能会提高散列表（hash tables）的性能。

&ensp;&ensp;&ensp;&ensp;**当没有覆盖 hashCode 而违反的关键约定是第二条：相等的对象必须具有相等的哈希码（ hash codes）。**

&ensp;&ensp;&ensp;&ensp;一个好的散列函数通常倾向于为不相等的实例生成不相等的哈希码。这也正是 hashCode 约定中第三条的表达。理想情况下，散列函数应该为集合中不相等的实例均匀地分配 int 范围内的哈希码。实现这种理想情况可能是困难的。 幸运的是，要获得一个合理的近似的方式并不难。 以下是一个简单的配方：

1. 声明一个 int 类型的变量 result，并将其初始化为对象中第一个重要属性 c 的哈希码，如下面步骤 2.a 中所计算的那样。（回顾条目 10，重要的属性是影响比较相等的领域。）
2. 对于对象中剩余的重要属性 f ，请执行以下操作：
   1. 为该域计算 int 类型的散列码 c：
      1. 如果该域是基本类型的，使用 `Type.hashCode(f)` 方法计算，其中 Type 类是对应属性 f 基本类型的包装类。
      2. 如果该属性是一个对象引用，并且该类的 equals 方法通过递归调用 equals 来比较该属性，并递归地调用 hashCode 方法。 如果需要更复杂的比较，则计算此字段的“范式（“canonical representation）”，并在范式上调用 hashCode。 如果该字段的值为空，则使用 0（也可以使用其他常数，但通常来使用 0 表示）。
      3. 如果属性 f 是一个数组，把它看作每个重要的元素都是一个独立的属性。 也就是说，通过递归地应用这些规则计算每个重要元素的哈希码，并且将每个步骤 2.b 的值合并。 如果数组没有重要的元素，则使用一个常量，最好不要为 0。如果所有元素都很重要，则使用 `Arrays.hashCode` 方法。
   2. 将步骤 2.a 中属性 c 计算出的哈希码合并为如下结果：` result = 31 * result + c;`
3. 返回 result 值。

&ensp;&ensp;&ensp;&ensp;可以从哈希码计算中排除衍生域（derived fields）。换句话说，如果一个属性的值可以根据参与计算的其他属性值计算出来，那么可以忽略这样的属性。您必须排除在 equals 比较中没有使用的任何属性，否则可能会违反 hashCode 约定的第二条。

&ensp;&ensp;&ensp;&ensp;步骤 2.b 中的乘法计算结果取决于属性的顺序，如果类中具有多个相似属性，则产生更好的散列函数。 例如，如果乘法计算从一个 String 散列函数中被省略，则所有的字符将具有相同的散列码。 之所以选择 31，因为它是一个奇数的素数。 如果它是偶数，并且乘法溢出，信息将会丢失，因为乘以 2 相当于移位。 使用素数的好处不太明显，但习惯上都是这么做的。 31 的一个很好的特性，是在一些体系结构中乘法可以被替换为移位和减法以获得更好的性能：` 31 * i ==（i << 5） - i `。 现代 JVM 可以自动进行这种优化。

```java
// Typical hashCode method
@Override
public int hashCode() {
    int result = Short.hashCode(areaCode);
    result = 31 * result + Short.hashCode(prefix);
    result = 31 * result + Short.hashCode(lineNum);
    return result;
}
```

&ensp;&ensp;&ensp;&ensp;Objects 类有一个静态方法，它接受任意数量的对象并为它们返回一个哈希码。 这个名为 hash 的方法可以让你编写一行 hashCode 方法，其质量与根据这个项目中的上面编写的方法相当。 不幸的是，它们的运行速度更慢，因为它们需要创建数组以传递可变数量的参数，以及如果任何参数是基本类型，则进行装箱和取消装箱。 这种哈希函数的风格建议仅在性能不重要的情况下使用。 以下是使用这种技术编写的 PhoneNumber 的哈希函数：

```java
// One-line hashCode method - mediocre performance
@Override
public int hashCode() {
    return Objects.hash(lineNum, prefix, areaCode);
}
```

如果一个类是不可变的，并且计算哈希码的代价很大，那么可以考虑在对象中缓存哈希码，而不是在每次请求时重新计算哈希码。 如果你认为这种类型的大多数对象将被用作哈希键，那么应该在创建实例时计算哈希码。 否则，可以选择延迟初始化（lazily initialize）哈希码。 需要注意确保类在存在延迟初始化属性的情况下保持线程安全。 PhoneNumber 类不适合这种情况，但只是为了展示它是如何完成的。 请注意，属性 hashCode 的初始值（在本例中为 0）不应该是通常创建的实例的哈希码：
```java
// hashCode method with lazily initialized cached hash code
private int hashCode;   // Automatically initialized to 0

@Override
public int hashCode() {
    int result = hashCode;
    if (result == 0) {
    result = Short.hashCode(areaCode);
    result = 31 * result + Short.hashCode(prefix);
    result = 31 * result + Short.hashCode(lineNum);
    hashCode = result;
    }
    return result;
}
```

**不要试图从哈希码计算中排除重要的属性来提高性能。** 由此产生的哈希函数可能运行得更快，但其质量较差可能会降低哈希表的性能，使其无法使用。 


  



