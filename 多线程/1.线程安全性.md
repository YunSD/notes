# ***线程安全性***




>1. 要编写线程安全的代码，其核心在于要对状态访问操作进行管理，特别是对共享的(Shared)和可变的(Mutable)状态的访问。  
>2. 非正式意义上，对象的状态是指存储在状态变量(例如实例或静态域）中的数据
>3. "共享"意味着变量可以由多个线程同时访问，而"可变"则意味着变量的值在生命周期内可以发生变化。
>4. 一个对象是否需要是线程安全的，取决于它是否被多个线程访问。
>>如果当多个线程访问同一个可变的状态变量时没有使用合适的同步，那么程序就会出现错误。有三个方式可以修复这个问腿：  
>>+ 不在线程之间共享该状态变量 
>>+ 将状态变量修改为不可变的变量
>>+ 在访问状态变量时使用同步  
>5. 完全由线程安全类构成的程序并不一定就是线程安全的，而在线程安全类中也可以包含非线程安全的类。
---

什么是线程安全性
----
---
>-  在线程安全性的定义中，最核心的概念就是安全性。安全性的定义是，某个类的行为与其规范完全一致。
>-  线程安全性定义：当多个线程访问某个类，这个类始终都能表现出正确的行为，那么就称这个类是线程安全的。
>>当多个线程访问某个类时，不管运行时环境采用何种调度方式或者这些线程将如何交替执行，并且在主调代码中不需要任何额外的同步或协同，这个类都能表现出正确的行为，那么就成这个类是线程安全的。
>-  无状态对象一定是线程安全的。

原子性
----
---
在并发编程中，由于不恰当的执行时序而出现不正确的结果是一种非常重要的情况，它有一个正式的名字：竞态条件(Race Condition)  
- ### 竞态条件
>- 当某个计算区取决于多个线程的交替执行时序时，那么就会发生竞态条件。换句话说，就是正确的结果取决于运气。最常见的静态条件类型就是“先检查后执行（Check-Then-Act）”操作，即通过一个可能失效的观测结果来确定下一步的动作。  
>- 静态条件的本质：基于一种可能失效的观察结果来做出判断或者执行某个计算。
>- 与大多数并发错误一样，竞态条件并不总是会产生错误，还需要某种不恰当的执行时序。  
- ### 复合操作
>- 包含了一组必须以原子方式执行的操作以确保线程安全性。
>- 在实际情况中，应尽可能地使用现有的线程安全对象（例如 AcomicLong）来管理类的状态。与非线程安全的对象相比，判断线程安全对象的可能状态及其状态转换状态情况要更为容易，从而也更容易维护和验证线程安全性。

加锁机制
----
---
要保持状态的一致性，就需要在单个原子操作中更新所有相关的状态变量。  
- ### 内置锁
>-    内置锁：java 提供了一种内置的锁机制来支持原子性：同步代码块(Synchronized Block)。同步代码块将包括两个部分：一个作为锁的对象引用，一个座位由这个锁保护的代码块。  
>-  每个java对象都可以用做一个实现同步的锁，这些锁被称为内置锁(Intrinsic Lock)或监视器锁(Monitor Lock),线程会在进入同步代码块之前自动获得锁，并且在退出同步代码块时自动释放锁，无论何种方式退出，获得内置锁得唯一途径就是进入由这个锁保护的同步代码块或方法。
>-  java 的内置锁相当于一种互斥体(或互斥锁)，这意味着最多只有一个线程能持有这种锁。


- ### 重入
>-  当某个线程请求一个由其他线程持有的锁时，发出请求的线程就会阻塞。然而，由于内置的锁是可重入的，因此如果某个线程试图获得一个已经有它自己持有的锁，那么这个请求就会成功
>- 重入的一种实现方式是，为每个锁关联一个获取计数值和一个持有者线程。当计数值喂 0 时，这个锁就认为是没有被任何线程持有。如果同一个线程再次获取这个锁，计数值将递增，而当线程退出同步代码块时，计数器会相应地递减，当计数值为0时，这个锁将被释放。  
>- 重入进一步提升了加锁行为的封装性，因此简化了面向对象并发代码的开发。

用锁来保护状态
----
---
>- 由于所能使其保护的代码路径以串行形式来访问，因此可以通过锁来构造一些协议以实现对共享状态的独占访问。只要始终遵循这些协议，就能确保状态的一致性。   
>- 如果用同步来协调对某个变量的访问，那么在访问这个变量的所有位置上都需要使用同步。而且，当使用锁来协调对某个变量的访问时，在访问变量的所有位置上都要使用同一个锁。
>> 对于可能被多个线程同时访问的可变状态变量，在访问它时都需要持有同一个锁，在这种情况下，我们称状态变量是有这个锁保护的。  
>>每个共享的和可变的变量都应该只由一个锁来保护，从而使维护人员知道是哪一个锁。
>- 一种常见的加锁约定是，将所有的可变的状态都封装在对象内部，并通过对象的内置锁对所有访问可变状态的代码路径进行同步，使得在该对象上不会发生并发访问。
>- 并非所有数据都需要锁的保护，只有被多个线程同时访问的可变数据才需要通过锁来保护。
>> 对于每个包含多个变量的不变性条件，其中涉及的所有变量都需要由同一个锁来保护。
>- 虽然 Synchronized 方法可以确保单个操作的原子性，但如果要把多个操作合并为一个复合操作，还是需要额外的加锁机制。

活跃性与性能
----
---
>- 使用 Synchronized 应该尽量将不影响共享状态且执行时间较长的操作从同步代码块中分离出去，从而这些操作的执行过程中，其他线程都可以访问共享状态。
>- 要判断同步代码块的合理大小，需要在各种设计需求之间进行权衡，包括安全性（必须满足）、简单性和性能。
>> 通常，在简单性和性能之间存在着相互制约因素。当实现某个同步策略时，一定不要盲目的为了性能而牺牲简单性（这可能会破坏安全性）。
>> 当执行时间较长的计算或者可能无法快速完成的操作时（例如：网络IO或控制台IO，），一定不要持有锁。
