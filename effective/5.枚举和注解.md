# ***枚举和注解***

- [***枚举和注解***](#枚举和注解)
  - [- 34.用 enum 代替 int 常量](#--34用-enum-代替-int-常量)
  - [34.用 enum 代替 int 常量](#34用-enum-代替-int-常量)
----

Java 支持两种特殊用途的引用类型：一种名为*枚举类型（enum type）*的类；另一种是名为*注解类型（annotation type）*的接口。 

## 34.用 enum 代替 int 常量

&ensp;&ensp;&ensp;&ensp;枚举类型是指一组固定的常量组成合法值的类型。在 Java 编程语言引入枚举类型之前，通常是用一组 int 常量来表示枚举类型。

```java
// The int enum pattern - severely deficient! 
public static final int APPLE_FUJI         = 0; 
public static final int APPLE_PIPPIN       = 1; 
public static final int APPLE_GRANNY_SMITH = 2;

public static final int ORANGE_NAVEL  = 0; 
public static final int ORANGE_TEMPLE = 1; 
public static final int ORANGE_BLOOD  = 2;。
```

这种方法称作 *int 枚举模式（int enum pattern）*,它存在着很多不足，int 枚举模式不具有类型安全性，也几乎没有描述性可言。采用 int 枚举模式的程序是十分脆弱的。因为 int 枚举是*编译时常量(constant variable)* [JLS, 4.12.4]，它们的 int 值会被编译到使用它们的客户端中。如果与 int 枚举常量关联的值发生了变化，客户端必须重新编译。如果没有重新编译，客户端程序还是可以运行，不过其行为已经不再准确。

这种模式还有一种变体，它使用的是 String 常量，而不是 int 常量。这样的变体被称作 String 枚举模式(String enum pattern),同样也不是我们期望的。它虽然为这些常量提供了可打印的字符串，但是会导致初级用户直接把字符串常量硬编码到客户端代码中，而不是使用对应的常量字段(field)名。一旦这样的硬编码字符串常量中包含书写错误，在编译时不会被检测到，但是在运行的时候却会报错。而且它会导致性能问题，因为它依赖于字符串的比较操作。 幸运的是，Java 提供了另一种替代的解决方案，可以避免 int 和 String 枚举模式的缺点，并提供更多的好处。这就是*枚举类型(enum type)* [JLS, 8.9]。 下面以最简单的形式演示了这种模式:

```java
public enum Apple  { FUJI, PIPPIN, GRANNY_SMITH } 
public enum Orange { NAVEL, TEMPLE, BLOOD }
```

Java 的枚举类型是完整的类，其功能比其他语言中的对应类更强大，Java 枚举本质本上是 int 值。 
 