# ***扩展点***

---

## 对象大小与指针压缩 

&ensp;&ensp;&ensp;&ensp;JDK 1.6 update14开始，在 64bit 操作系统中，JVM 开始支持指针压缩。

&ensp;&ensp;&ensp;&ensp;JVM 配置参数:`UseCompressedOops­­`，compressed -- 压缩、oop(ordinary object pointer) -- ­­对象指针。

&ensp;&ensp;&ensp;&ensp;启用指针压缩:`­XX:+UseCompressedOops`(默认开启)，禁止指针压缩:­`XX:­UseCompressedOops`。

&ensp;&ensp;&ensp;&ensp;为什么要进行指针压缩？ 
1. 在 64 位平台的 HotSpot 中使用 32 位指针，内存使用会多出 1.5 倍左右，使用较大指针在主内存和缓存之间移动数据， 占用较大宽带，同时 GC 也会承受较大压力。 
2. 为了减少 64 位平台下内存的消耗，启用指针压缩功能。
3. 在 JVM 中，32 位地址最大支持 4G 内存( 2 的 32 次方)，可以通过对象指针的压缩编码、解码方式进行优化，使得 JVM 只用 32 位地址就可以支持更大的内存配置(小于等于 32G ) 
4. 堆内存小于 4G 时，不需要启用指针压缩，JVM 会直接去除高 32 位地址，即使用低虚拟地址空间 \
5. 堆内存大于 32G 时，压缩指针会失效，会强制使用 64 位(即 8 字节)来对 java 对象寻址，这就会出现 1 的问题，所以堆内存不要大于 32G 为好。

&ensp;&ensp;&ensp;&ensp;对象大小可以用`jol­-core`包查看，引入依赖:

```java
<dependency>
    <groupId>org.openjdk.jol</groupId> 
    <artifactId>jol‐core</artifactId>
    <version>0.9</version> 
</dependency>
```

```java
public class JOLSample {

public static void main(String[] args) {
    ClassLayout layout = ClassLayout.parseInstance(new Object()); 
    System.out.println(layout.toPrintable());

    ClassLayout layout1 = ClassLayout.parseInstance(new int[]{}); 
    System.out.println(layout1.toPrintable());

    ClassLayout layout2 = ClassLayout.parseInstance(new A()); 
    System.out.println(layout2.toPrintable());
}


// ‐XX:+UseCompressedOops 默认开启的压缩所有指针 
// ‐XX:+UseCompressedClassPointers 默认开启的压缩对象头里的类型指针Klass Pointer 
// Oops : Ordinary Object Pointers 
public static class A { 
    //8B mark word 
    //4B Klass Pointer 如果关闭压缩 ‐XX:‐UseCompressedClassPointers或‐XX:‐UseCompressedOops，则占用 8B 
    int id; //4B 
    String name; //4B 如果关闭压缩‐XX:‐UseCompressedOops，则占用8B 
    byte b; //1B 
    Object o; //4B 如果关闭压缩‐XX:‐UseCompressedOops，则占用8B 
    } 
}


output:
    java.lang.Object object internals: 
    OFFSET SIZE TYPE DESCRIPTION VALUE 
    0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1) //mark word 
    4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) //mark word 
    8 4 (object header) e5 01 00 f8 (11100101 00000001 00000000 11111000) (‐134217243) //Klass Pointer
    12 4 (loss due to the next object alignment) 
    Instance size: 16 bytes 
    Space losses: 0 bytes internal + 4 bytes external = 4 bytes total


    [I object internals: 
    OFFSET SIZE TYPE DESCRIPTION VALUE 
    0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1)  
    4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0)  
    8 4 (object header) 6d 01 00 f8 (01101101 00000001 00000000 11111000)(‐134217363) 
    12 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0)
    16 0 int [I.<elements> N/A 
    Instance size: 16 bytes 
    Space losses: 0 bytes internal + 0 bytes external = 0 bytes total

    com.tuling.jvm.JOLSample$A object internals: 
    OFFSET SIZE TYPE DESCRIPTION VALUE
    0 4 (object header) 01 00 00 00 (00000001 00000000 00000000 00000000) (1)
    4 4 (object header) 00 00 00 00 (00000000 00000000 00000000 00000000) (0) 
    8 4 (object header) 61 cc 00 f8 (01100001 11001100 00000000 11111000) (‐134165407) 
    12 4 int A.id 0 
    16 1 byte A.b 0 
        17 3 (alignment/padding gap) 
    20 4 java.lang.String A.name null 
    24 4 java.lang.Object A.o null 
    28 4 (loss due to the next object alignment) 
    Instance size: 32 bytes 
    Space losses: 3 bytes internal + 4 bytes external = 7 bytes total

```


## 对象内存分配

