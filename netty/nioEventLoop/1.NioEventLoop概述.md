# ***NioEventLoop 概述***

三个问题
----
---
>- 默认情况下，Netty 服务端启多个线程？何时启动？

>- Netty 是如何解决 JDK 空轮询 BUG?

>- Netty 是如何保证异步串行无锁化?

NioEventLoop 学习流程
----
---
>- NioEventLoop 创建

>- NioEventLoop 启动

>- NioEventLoop 执行逻辑

---
---
---

NioEventLoop 创建
----
---
>`new NioEventLoopGroup()` **<font color=#FF0000 >[ 线程组，默认 2 * CPU ] </font>**

>>`new ThreadPerTaskExecutor()` **<font color=#FF0000 >[ 线程执行器 ] </font>**

>>`for(){ newChild() }` **<font color=#FF0000 >[ 构造 NioEventLoop ] </font>**

>>`chooserFactory.newChooser()` **<font color=#FF0000 >[ 线程选择器 ] </font>**

---
`EventLoopGroup bossGroup = new NioEventLoopGroup(1);`

MultithreadEventLoopGroup.java
----
---
>构造方法：
>`DEFAULT_EVENT_LOOP_THREADS` 默认初始线程数为 处理器个数 × 2
```java
    private static final int DEFAULT_EVENT_LOOP_THREADS;

    static {
        DEFAULT_EVENT_LOOP_THREADS = Math.max(1, SystemPropertyUtil.getInt(
                "io.netty.eventLoopThreads", Runtime.getRuntime().availableProcessors() * 2));

        if (logger.isDebugEnabled()) {
            logger.debug("-Dio.netty.eventLoopThreads: {}", DEFAULT_EVENT_LOOP_THREADS);
        }
    }

    /**
     * @see {@link MultithreadEventExecutorGroup#MultithreadEventExecutorGroup(int, Executor, Object...)}
     */
    protected MultithreadEventLoopGroup(int nThreads, Executor executor, Object... args) {
        super(nThreads == 0 ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);
    }

```
MultithreadEventExecutorGroup.java
----
---
>`DefaultEventExecutorChooserFactory.INSTANCE` 是创建的 线程选择器

>`MultithreadEventExecutorGroup` 作为 `MultithreadEventLoopGroup` 的父类。

>1. 创建线程选择器

>> ``` executor = new ThreadPerTaskExecutor(newDefaultThreadFactory()); ```

>2. 通过 for 循环创建 NioEventLoop

>3. 创建线程选择器
```java
    public static final DefaultEventExecutorChooserFactory INSTANCE = new DefaultEventExecutorChooserFactory();

    protected MultithreadEventExecutorGroup(int nThreads, Executor executor, Object... args) {
        this(nThreads, executor, DefaultEventExecutorChooserFactory.INSTANCE, args);
    }

    protected MultithreadEventExecutorGroup(int nThreads, Executor executor, EventExecutorChooserFactory  chooserFactory, Object... args) {
        if (nThreads <= 0) {
            throw new IllegalArgumentException(String.format("nThreads: %d (expected: > 0)", nThreads));
        }

        if (executor == null) {
            executor = new ThreadPerTaskExecutor(newDefaultThreadFactory());
        }

        children = new EventExecutor[nThreads];

        for (int i = 0; i < nThreads; i ++) {
            boolean success = false;
            try {
                children[i] = newChild(executor, args);
                success = true;
            } catch (Exception e) {
                // TODO: Think about if this is a good exception type
                throw new IllegalStateException("failed to create a child event loop", e);
            } finally {
                if (!success) {
                    for (int j = 0; j < i; j ++) {
                        children[j].shutdownGracefully();
                    }

                    for (int j = 0; j < i; j ++) {
                        EventExecutor e = children[j];
                        try {
                            while (!e.isTerminated()) {
                                e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);
                            }
                        } catch (InterruptedException interrupted) {
                            // Let the caller handle the interruption.
                            Thread.currentThread().interrupt();
                            break;
                        }
                    }
                }
            }
        }

        chooser = chooserFactory.newChooser(children);

        final FutureListener<Object> terminationListener = new FutureListener<Object>() {
            @Override
            public void operationComplete(Future<Object> future) throws Exception {
                if (terminatedChildren.incrementAndGet() == children.length) {
                    terminationFuture.setSuccess(null);
                }
            }
        };

        for (EventExecutor e: children) {
            e.terminationFuture().addListener(terminationListener);
        }

        Set<EventExecutor> childrenSet = new LinkedHashSet<EventExecutor>(children.length);
        Collections.addAll(childrenSet, children);
        readonlyChildren = Collections.unmodifiableSet(childrenSet);
    }
```

ThreadperTaskExecutor
----
---
>- 每次执行任务都会创建一个线程实体
